flush ruleset

define wan = <WAN-INTERFACE>
define vpn = wg0
define vpn_net = 10.200.200.0/24

table inet firewall {
    set tcp_accepted {
        type inet_service;
        elements = {
            80,
            443,
        }
    }

    set udp_accepted {
        type inet_service;
        elements = {
            51820
        }
    }

    chain input {
        type filter hook input priority 0; policy drop;

        # Limit ping requests.
        ip protocol icmp icmp type echo-request limit rate over 1/second burst 5 packets drop
        ip6 nexthdr icmpv6 icmpv6 type echo-request limit rate over 1/second burst 5 packets drop

        # Allow all established and related traffic.
        ct state established,related accept

        # Allow loopback.
        iif lo accept

        # Allow specific ICMP types.
        ip protocol icmp icmp type {
            destination-unreachable,
            echo-reply,
            echo-request,
            source-quench,
            time-exceeded
        } accept

        # Allow specific ICMPv6 types.
        ip6 nexthdr icmpv6 icmpv6 type {
            destination-unreachable,
            echo-reply,
            echo-request,
            nd-neighbor-advert,
            nd-neighbor-solicit,
            nd-router-advert,
            packet-too-big,
            parameter-problem,
            time-exceeded
        } accept

        # Allow the specified TCP and UDP ports.
        iifname $wan tcp dport @tcp_accepted ct state new accept
        iifname $wan udp dport @udp_accepted ct state new accept

        # Allow VPN peers to access DNS, SSH (on 10022) and services.
        iifname $vpn udp dport 53 ct state new accept
        iifname $vpn tcp dport 53 ct state new accept
        iifname $vpn tcp dport 10022 ct state new accept
        iifname $vpn tcp dport @tcp_accepted ct state new accept
        iifname $vpn udp dport @udp_accepted ct state new accept
    }

    chain forward {
        type filter hook forward priority 0; policy drop;

        # Allow all established and related traffic.
        ct state established,related accept

        # Allow VPN traffic to access the internet via wan.
        iifname $vpn oifname $wan ct state new accept
    }

    chain output {
        # Allow all outgoing traffic.
        type filter hook output priority 0; policy drop;

        # Explicitly allow outgoing traffic; ICMPv6 must be set manually.
        ip6 nexthdr ipv6-icmp accept
        ct state new,established,related accept
    }
}

table inet router {
    chain postrouting {
        type nat hook postrouting priority 100;

        # Masquerade VPN traffic.
        oifname $wan ip saddr $vpn_net masquerade
    }
}

table netdev filter {
    # IPv4 bogons.
    set ipv4_blocklist {
        type ipv4_addr;
        elements = {
            0.0.0.0/8
            10.0.0.0/8
            100.64.0.0/10
            127.0.0.0/8
            169.254.0.0/16
            172.16.0.0/12
            192.0.0.0/24
            192.0.2.0/24
            192.168.0.0/16
            198.18.0.0/15
            198.51.100.0/24
            203.0.113.0/24
            224.0.0.0/4
            240.0.0.0/4
        }
    }

    chain ingress {
        # The priority ensures that the chain will be evaluated before any other
        # one registered on the ingress hook.
        # The interface must be set explicitly here, not from a variable.
        type filter hook ingress device <WAN-INTERFACE> priority -500;

        # Drop IP fragments.
        ip frag-off & 0x1fff != 0 counter drop

        # Drop bad addresses.
        ip saddr @ipv4_blocklist counter drop

        # Drop TCP Christmas tree packets.
        tcp flags & (fin|syn|rst|psh|ack|urg) == fin|syn|rst|psh|ack|urg counter drop

        # Drop TCP null packets.
        tcp flags & (fin|syn|rst|psh|ack|urg) == 0x0 counter drop

        # Drop uncommon MSS values.
        tcp flags syn tcp option maxseg size 1-535 counter drop
    }
}

table inet mangle {
    chain prerouting {
        type filter hook prerouting priority -150;

        # Drop invalid packets.
        ct state invalid counter drop

        # Drop new TCP packets that are not SYN.
        tcp flags & (fin|syn|rst|ack) != syn ct state new counter drop
    }
}
