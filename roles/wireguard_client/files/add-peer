#!/bin/sh
set -euf

usage="Usage: $(/usr/bin/basename "$0") OPTIONS

Add a new WireGuard client. Its configuration is written to the standard
output, which can be piped to 'qrencode -t ansiutf8' if adding a mobile phone
client.

Options:
  -n TEXT     Name of the client, used to comment the configuration.
  -4 IPv4     IPv4 address of the client within the VPN.
  -6 IPv6     IPv6 address of the client within the VPN.
  -a SUBNET   Additional values for the AllowedIPs clause in the [Peer] section
              of the client in the server configuration. Can be repeated.
  -e IP:PORT  Public IP address and WireGuard port of the server.
  -c FILE     Path to the WireGuard config of the server.
  -t TEXT     Tunneling type:
              - 'access': Only grant access to the server.
              - 'access-dns': Only grant access to the server and set the
                server as the client DNS resolver.
              - 'access-dns-resolved': Only grant access to the server, set the
                server as the client DNS resolver, assume systemd-resolved for
                the client.
              - 'full': Setup full tunneling and set the server as the client
                DNS resolver.
              - 'full-resolved': Setup full tunneling, set the server as the
                client DNS resolver, assume systemd-resolved for the client.
  -k INT      Send keepalive packets every k seconds (disabled by default).
              Allows to keep the connection alive if the client is behind a NAT.
              The WireGuard documentation suggests a value of 25 (seconds).
  -g          Assume the added client is a gateway and add its [Peer] section
              to a file separate from the server WireGuard config. To be used
              with the overlay-network service.
  -h          Show this message and exit."

gateway_config='/etc/wireguard/wg-gateway.conf'

die() {
  printf '%s\n' "$1" >&2
  exit 1
}

check_arg() {
  if [ -z "$1" ]; then
    die 'Missing value for the %s\n.' "$2"
  fi
}

check_unique() {
  name="$1"
  clientipv4="$2"
  clientipv6="$3"
  config="$4"

  if /usr/bin/grep -q "#\s*${name}$" "${config}"; then
    die 'A client with this name already exists.'
  fi

  if /usr/bin/grep -q "AllowedIPs\s*=\s*${clientipv4}/32$" "${config}"; then
    die 'A client with this IPv4 address already exists.'
  fi

  if /usr/bin/grep -q "AllowedIPs\s*=\s*${clientipv6}/128$" "${config}"; then
    die 'A client with this IPv6 address already exists.'
  fi
}

generate_peer_clause() {
  name="$1"
  clientipv4="$2"
  clientipv6="$3"
  allowedips="$4"
  publickey="$5"
  presharedkey="$6"

  printf '\n'
  printf '# %s\n' "${name}"
  printf '[Peer]\n'
  printf 'PublicKey = %s\n' "${publickey}"
  printf 'PresharedKey = %s\n' "${presharedkey}"
  printf 'AllowedIPs = %s/32\n' "${clientipv4}"
  printf 'AllowedIPs = %s/128\n' "${clientipv6}"

  if [ -n "${allowedips}" ]; then
    printf '%s\n' "${allowedips}" \
      | /usr/bin/tr ',' '\n' \
      | while read -r subnet; do
      printf 'AllowedIPs = %s\n' "${subnet}"
    done
  fi
}

generate_client_config() {
  clientipv4="${1}"
  clientipv6="${2}"
  endpoint="${3}"
  tunneling="${4}"
  privatekey="${5}"
  presharedkey="${6}"
  serveripv4="${7}"
  serveripv6="${8}"
  serverpublickey="${9}"
  keepalive="${10}"

  printf '[Interface]\n'
  printf 'Address = %s/32\n' "${clientipv4}"
  printf 'Address = %s/128\n' "${clientipv6}"
  printf 'PrivateKey = %s\n' "${privatekey}"

  if [ "${tunneling}" = 'access-dns' ] || [ "${tunneling}" = 'full' ]; then
    printf 'DNS = %s\n' "${serveripv4}"
    printf 'DNS = %s\n' "${serveripv6}"
  elif [ "${tunneling}" = 'access-dns-resolved' ] \
    || [ "${tunneling}" = 'full-resolved' ]; then
    printf 'DNS = %s\n' "${serveripv4}"
    printf 'DNS = %s\n' "${serveripv6}"
    printf 'PostUp = resolvectl dns %%i %s %s;' "${serveripv4}" "${serveripv6}"
    printf 'resolvectl domain %%i "~.";'
    printf 'resolvectl default-route %%i true\n'
    printf 'PreDown = resolvectl revert %%i\n'
  fi

  printf '\n'
  printf '[Peer]\n'
  printf 'PublicKey = %s\n' "${serverpublickey}"
  printf 'PresharedKey = %s\n' "${presharedkey}"
  printf 'Endpoint = %s\n' "${endpoint}"

  if [ "${tunneling}" = 'access' ] \
    || [ "${tunneling}" = 'access-dns' ] \
    || [ "${tunneling}" = 'access-dns-resolved' ]; then
    printf 'AllowedIPs = %s/32\n' "${serveripv4}"
    printf 'AllowedIPs = %s/128\n' "${serveripv6}"
  else
    printf 'AllowedIPs = 0.0.0.0/0\n'
    printf 'AllowedIPs = ::/0\n'
  fi

  if [ "${keepalive}" -gt 0 ]; then
    printf 'PersistentKeepalive = %d\n' "${keepalive}"
  fi
}

main() {
  euid="$(/usr/bin/id -u)"
  name=''
  clientipv4=''
  clientipv6=''
  allowedips=''
  endpoint=''
  config=''
  tunneling=''
  keepalive=0
  gateway=false

  if [ "${euid}" != 0 ]; then
    die 'Run the script as root.'
  fi

  while getopts 'h4:6:a:n:e:c:t:k:g' arg; do
    case "${arg}" in
      h) printf '%s\n' "${usage}"; exit 0 ;;
      n) name="${OPTARG}" ;;
      4) clientipv4="${OPTARG}" ;;
      6) clientipv6="${OPTARG}" ;;
      a) allowedips="${allowedips:+${allowedips},}${OPTARG}" ;;
      e) endpoint="${OPTARG}" ;;
      c) config="${OPTARG}" ;;
      t) tunneling="${OPTARG}" ;;
      k) keepalive="${OPTARG}" ;;
      g) gateway=true ;;
      *) printf '%s\n' "${usage}"; exit 1 ;;
    esac
  done

  check_arg "${name}" 'client name'
  check_arg "${clientipv4}" 'client IPv4 address inside the VPN'
  check_arg "${clientipv6}" 'client IPv6 address inside the VPN'
  check_arg "${endpoint}" 'endpoint'
  check_arg "${config}" 'server WireGuard config path'
  check_arg "${tunneling}" 'tunneling type'

  if [ "${tunneling}" != 'access' ] \
    && [ "${tunneling}" != 'access-dns' ] \
    && [ "${tunneling}" != 'access-dns-resolved' ] \
    && [ "${tunneling}" != 'full' ] \
    && [ "${tunneling}" != 'full-resolved' ]; then
    die 'Invalid tunneling value.'
  fi

  if [ ! -f "${config}" ]; then
    die 'The config file does not exist.'
  fi

  check_unique "${name}" "${clientipv4}" "${clientipv6}" "${config}"

  if [ -f "${gateway_config}" ]; then
    check_unique "${name}" "${clientipv4}" "${clientipv6}" "${gateway_config}"
  fi

  serveripv4=$(/usr/sbin/ip -4 addr show dev wg0 \
    | /usr/bin/awk '/inet/ {print $2}' \
    | /usr/bin/cut -d/ -f1)
  serveripv6=$(/usr/sbin/ip -6 addr show dev wg0 \
    | /usr/bin/awk '/inet6/ {print $2}' \
    | /usr/bin/cut -d/ -f1)

  serverpublickey=$(/usr/bin/sed -n 's/^PrivateKey\s*=\s*\(.*\)$/\1/p' \
    "${config}" | /usr/bin/wg pubkey)

  privatekey=$(/usr/bin/wg genkey)
  publickey=$(printf '%s' "${privatekey}" | /usr/bin/wg pubkey)
  presharedkey=$(/usr/bin/wg genpsk)

  if "${gateway}"; then
    target="${gateway_config}"
  else
    target="${config}"
  fi

  (
    umask 0077
    generate_peer_clause \
      "${name}" \
      "${clientipv4}" \
      "${clientipv6}" \
      "${allowedips}" \
      "${publickey}" \
      "${presharedkey}" \
      >> "${target}"
  )

  generate_client_config \
    "${clientipv4}" \
    "${clientipv6}" \
    "${endpoint}" \
    "${tunneling}" \
    "${privatekey}" \
    "${presharedkey}" \
    "${serveripv4}" \
    "${serveripv6}" \
    "${serverpublickey}" \
    "${keepalive}"

  /usr/bin/systemctl reload wg-quick@wg0.service
}

main "$@"
