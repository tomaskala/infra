#!/bin/sh
set -euf

usage="Usage: $(/usr/bin/basename "$0") OPTIONS

Add a new WireGuard client. Its configuration is written to the standard
output, which can be piped to 'qrencode -t ansiutf8' if adding a mobile phone
client.

Options:
  -n TEXT     Name of the client, used to comment the configuration.
  -4 IPv4     IPv4 address of the client within the VPN.
  -6 IPv6     IPv6 address of the client within the VPN.
  -a SUBNET   Additional values for the AllowedIPs clause in the [Peer] section
              of the client in the server configuration. Can be repeated.
  -e IP:PORT  Public IP address and WireGuard port of the server.
  -c FILE     Path to the WireGuard config of the server.
  -t TEXT     Tunneling type. Either 'full' for full tunneling of all client
              traffic, or a subnet to be tunneled through the server. In the
              latter case, the option can be repeated.
              When omitted or not 'full', access to the server is granted
              automatically.
              Setting 'full' requires '-d' to be set; an error is raised
              otherwise.
  -d          Set the server as the client's DNS resolver.
  -r          Assume the client is using systemd-resolved. Only makes sense
              if '-d' is set; an error is raised otherwise.
  -k INT      Send keepalive packets every k seconds (disabled by default).
              Allows to keep the connection alive if the client is behind a NAT.
              The WireGuard documentation suggests a value of 25 (seconds).
  -g          Assume the added client is a gateway and add its [Peer] section
              to a file separate from the server WireGuard config. To be used
              with the overlay-network service.
  -h          Show this message and exit."

gateway_config='/etc/wireguard/wg-gateway.conf'

die() {
  printf '%s\n' "$1" >&2
  exit 1
}

check_arg() {
  if [ -z "$1" ]; then
    die 'Missing value for the %s\n.' "$2"
  fi
}

check_unique() {
  if /usr/bin/grep -q "#\s*$1$" "$4"; then
    die 'A client with this name already exists.'
  fi

  if /usr/bin/grep -q "AllowedIPs\s*=\s*$2/32$" "$4"; then
    die 'A client with this IPv4 address already exists.'
  fi

  if /usr/bin/grep -q "AllowedIPs\s*=\s*$3/128$" "$4"; then
    die 'A client with this IPv6 address already exists.'
  fi
}

generate_peer_clause() {
  name="$1"
  clientipv4="$2"
  clientipv6="$3"
  allowedips="$4"
  publickey="$5"
  presharedkey="$6"

  printf '\n'
  printf '# %s\n' "${name}"
  printf '[Peer]\n'
  printf 'PublicKey = %s\n' "${publickey}"
  printf 'PresharedKey = %s\n' "${presharedkey}"
  printf 'AllowedIPs = %s/32\n' "${clientipv4}"
  printf 'AllowedIPs = %s/128\n' "${clientipv6}"

  if [ -n "${allowedips}" ]; then
    printf '%s\n' "${allowedips}" \
      | /usr/bin/tr ',' '\n' \
      | while read -r subnet; do
      printf 'AllowedIPs = %s\n' "${subnet}"
    done
  fi
}

generate_client_config() {
  clientipv4="${1}"
  clientipv6="${2}"
  endpoint="${3}"
  tunneling="${4}"
  dns="${5}"
  resolved="${6}"
  privatekey="${7}"
  presharedkey="${8}"
  serveripv4="${9}"
  serveripv6="${10}"
  serverpublickey="${11}"
  keepalive="${12}"

  printf '[Interface]\n'
  printf 'Address = %s/32\n' "${clientipv4}"
  printf 'Address = %s/128\n' "${clientipv6}"
  printf 'PrivateKey = %s\n' "${privatekey}"

  if "${dns}"; then
    printf 'DNS = %s\n' "${serveripv4}"
    printf 'DNS = %s\n' "${serveripv6}"
  fi

  if "${resolved}"; then
    printf 'PostUp = resolvectl dns %%i %s %s;' "${serveripv4}" "${serveripv6}"
    printf 'resolvectl domain %%i "~.";'
    printf 'resolvectl default-route %%i true\n'
    printf 'PreDown = resolvectl revert %%i\n'
  fi

  printf '\n'
  printf '[Peer]\n'
  printf 'PublicKey = %s\n' "${serverpublickey}"
  printf 'PresharedKey = %s\n' "${presharedkey}"
  printf 'Endpoint = %s\n' "${endpoint}"

  if [ "${tunneling}" = 'full' ]; then
    printf 'AllowedIPs = 0.0.0.0/0\n'
    printf 'AllowedIPs = ::/0\n'
  else
    printf 'AllowedIPs = %s/32\n' "${serveripv4}"
    printf 'AllowedIPs = %s/128\n' "${serveripv6}"

    if [ -n "${tunneling}" ]; then
      printf '%s\n' "${tunneling}" \
        | /usr/bin/tr ',' '\n' \
        | while read -r subnet; do
        printf 'AllowedIPs = %s\n' "${subnet}"
      done
    fi
  fi

  if [ "${keepalive}" -gt 0 ]; then
    printf 'PersistentKeepalive = %d\n' "${keepalive}"
  fi
}

main() {
  euid="$(/usr/bin/id -u)"
  name=''
  clientipv4=''
  clientipv6=''
  allowedips=''
  endpoint=''
  config=''
  tunneling=''
  dns=false
  resolved=false
  keepalive=0
  gateway=false

  full_tunnel=false

  if [ "${euid}" != 0 ]; then
    die 'Run the script as root.'
  fi

  while getopts 'h4:6:a:n:e:c:t:drk:g' arg; do
    case "${arg}" in
      h) printf '%s\n' "${usage}"; exit 0 ;;
      n) name="${OPTARG}" ;;
      4) clientipv4="${OPTARG}" ;;
      6) clientipv6="${OPTARG}" ;;
      a) allowedips="${allowedips:+${allowedips},}${OPTARG}" ;;
      e) endpoint="${OPTARG}" ;;
      c) config="${OPTARG}" ;;
      t)
        tunneling="${tunneling:+${tunneling},}${OPTARG}"
        [ "${OPTARG}" = 'full' ] && full_tunnel=true
        ;;
      d) dns=true ;;
      r) resolved=true ;;
      k) keepalive="${OPTARG}" ;;
      g) gateway=true ;;
      *) printf '%s\n' "${usage}"; exit 1 ;;
    esac
  done

  check_arg "${name}" 'client name'
  check_arg "${clientipv4}" 'client IPv4 address inside the VPN'
  check_arg "${clientipv6}" 'client IPv6 address inside the VPN'
  check_arg "${endpoint}" 'endpoint'
  check_arg "${config}" 'server WireGuard config path'

  if [ ! -f "${config}" ]; then
    die 'The config file does not exist.'
  fi

  check_unique "${name}" "${clientipv4}" "${clientipv6}" "${config}"

  if [ -f "${gateway_config}" ]; then
    check_unique "${name}" "${clientipv4}" "${clientipv6}" "${gateway_config}"
  fi

  if ! "${dns}" && "${resolved}"; then
    die 'Assuming systemd-resolved does not make sense without setting dns.'
  fi

  if "${full_tunnel}" && [ "${tunneling}" != 'full' ]; then
    die 'If using full tunneling, specifying additional subnets to be tunneled does not make sense.'
  fi

  if ! "${dns}" && "${full_tunnel}"; then
    die 'If using full tunneling, set also dns and double check whether systemd-resolved is used on the client.'
  fi

  serveripv4=$(/usr/sbin/ip -4 addr show dev wg0 \
    | /usr/bin/awk '/inet/ {print $2}' \
    | /usr/bin/cut -d/ -f1)
  serveripv6=$(/usr/sbin/ip -6 addr show dev wg0 \
    | /usr/bin/awk '/inet6/ {print $2}' \
    | /usr/bin/cut -d/ -f1)

  serverpublickey=$(/usr/bin/sed -n 's/^PrivateKey\s*=\s*\(.*\)$/\1/p' \
    "${config}" | /usr/bin/wg pubkey)

  privatekey=$(/usr/bin/wg genkey)
  publickey=$(printf '%s' "${privatekey}" | /usr/bin/wg pubkey)
  presharedkey=$(/usr/bin/wg genpsk)

  if "${gateway}"; then
    target="${gateway_config}"
  else
    target="${config}"
  fi

  (
    umask 0077
    generate_peer_clause \
      "${name}" \
      "${clientipv4}" \
      "${clientipv6}" \
      "${allowedips}" \
      "${publickey}" \
      "${presharedkey}" \
      >> "${target}"
  )

  generate_client_config \
    "${clientipv4}" \
    "${clientipv6}" \
    "${endpoint}" \
    "${tunneling}" \
    "${dns}" \
    "${resolved}" \
    "${privatekey}" \
    "${presharedkey}" \
    "${serveripv4}" \
    "${serveripv6}" \
    "${serverpublickey}" \
    "${keepalive}"

  /usr/bin/systemctl reload wg-quick@wg0.service
}

main "$@"
